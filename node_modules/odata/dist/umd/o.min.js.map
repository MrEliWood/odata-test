{"version":3,"file":"o.min.js","sources":["../../src/o.ts","../../src/ORequest.ts","../../src/OBatch.ts","../../src/OHandler.ts"],"sourcesContent":["import { OdataConfig } from \"./OdataConfig\";\nimport { OHandler } from \"./OHandler\";\n\n/**\n * Use the 'o'-function to initialize a request directly or use the returned\n * handler to store the settings.\n *\n * Use o() directly jquery like:\n * @example\n * ```typescript\n *  await o('https://rootUrl').get('resource').query();\n * ```\n *\n * Or with a handler:\n * @example\n * ```typescript\n *  const oHandler = o('https://rootUrl');\n *  await oHandler.get('resource').query({ $top: 2 });\n * ```\n *\n * @param rootUrl The url to query\n * @param config The odata and fetch configuration.\n */\nexport function o(\n  rootUrl: string | URL,\n  config: Partial<OdataConfig> = {}\n) {\n  // polyfill fetch if we have no fetch\n  const env = typeof window !== \"undefined\" ? window : global;\n  if (\n    !(\"fetch\" in env) &&\n    !config.disablePolyfill &&\n    typeof window !== \"undefined\"\n  ) {\n    throw new Error(\n      \"No polyfill found for fetch(). You need to include dist/umd/o.polyfill.js to work with older browsers\"\n    );\n  }\n\n  if (\n    !(\"fetch\" in env) &&\n    !config.disablePolyfill &&\n    typeof window === \"undefined\"\n  ) {\n    require(\"cross-fetch/polyfill\");\n  }\n\n  if (\n    !(\"URL\" in env) &&\n    !config.disablePolyfill &&\n    typeof window !== \"undefined\"\n  ) {\n    throw new Error(\n      \"No polyfill found for URL(). You need to include dist/umd/o.polyfill.js to work with older browsers\"\n    );\n  }\n\n  if (\n    !(\"URL\" in env) &&\n    !config.disablePolyfill &&\n    typeof window === \"undefined\"\n  ) {\n    require(\"universal-url\").shim();\n  }\n\n  // set the default configuration values\n  const defaultConfigValues: OdataConfig = {\n    batch: {\n      boundaryPrefix: \"batch_\",\n      changsetBoundaryPrefix: \"changset_\",\n      endpoint: \"$batch\",\n      headers: new Headers({\n        \"Content-Type\": \"multipart/mixed\",\n      }),\n      useChangset: false,\n      useRelativeURLs: false,\n    },\n    credentials: \"omit\",\n    fragment: \"value\",\n    headers: new Headers({\n      \"Content-Type\": \"application/json\",\n    }),\n    mode: \"cors\",\n    redirect: \"follow\",\n    referrer: \"client\",\n    onStart: () => null,\n    onError: () => null,\n    onFinish: () => null,\n  };\n\n  const mergedConfig: OdataConfig = { ...defaultConfigValues, ...config };\n  if (typeof rootUrl === \"string\") {\n    try {\n      // we assuming a resource\n      const configUrl = (mergedConfig.rootUrl ||\n        window.location.href) as string;\n      rootUrl = new URL(\n        rootUrl,\n        configUrl.endsWith(\"/\") ? configUrl : `${configUrl}/`\n      );\n    } catch (ex) {\n      // no window?!\n      rootUrl = new URL(rootUrl as string, mergedConfig.rootUrl);\n    }\n  }\n  mergedConfig.rootUrl = rootUrl;\n  return new OHandler(mergedConfig);\n}\n\n/**\n * Default exports\n */\nexport * from \"./OBatch\";\nexport * from \"./OdataConfig\";\nexport * from \"./OdataQuery\";\nexport * from \"./OHandler\";\nexport * from \"./ORequest\";\n","import { OdataQuery } from \"./OdataQuery\";\n\nexport class ORequest {\n  public url: URL;\n\n  constructor(url: URL | string, public config: RequestInit) {\n    if (typeof url === \"string\") {\n      this.url = new URL(url);\n    } else {\n      this.url = url as URL;\n    }\n  }\n\n  public get fetch() {\n    const req = new Request(this.url.href, this.config);\n    return fetch(req, this.config);\n  }\n\n  public applyQuery(query?: OdataQuery) {\n    for (const key in query) {\n      if (query.hasOwnProperty(key)) {\n        if (this.url.searchParams.get(key)) {\n          this.url.searchParams.set(key, query[key]);\n        } else {\n          this.url.searchParams.append(key, query[key]);\n        }\n      }\n    }\n  }\n}\n","import { OdataConfig } from \"./OdataConfig\";\nimport { OdataQuery } from \"./OdataQuery\";\nimport { ORequest } from \"./ORequest\";\n\nconst CRLF = \"\\r\\n\";\n\nexport class OBatch {\n  // \"\" here prevents 'undefined' at start of body under some conditions.\n  private batchBody = \"\";\n  private batchUid;\n  private batchConfig: OdataConfig;\n\n  constructor(\n    resources: ORequest[],\n    config: OdataConfig,\n    query?: OdataQuery,\n    private changeset: boolean = false,\n  ) {\n    this.batchConfig = { ...config, ...config.batch };\n    this.batchUid = this.getUid();\n    (this.batchConfig.headers as Headers).set(\n       \"Content-Type\",\n       `multipart/mixed; boundary=${this.batchUid}`,\n    );\n\n    if (this.batchConfig.batch.useChangset) {\n      resources = this.checkForChangset(resources, query);\n    } else {\n      this.batchBody += `--${this.batchUid}`;\n    }\n\n    resources.forEach(\n      (req) => req.config.method === \"GET\" && req.applyQuery(query),\n    );\n    let contentId = 0;\n    this.batchBody += resources.map((req) => {\n      contentId++;\n      return [\n        \"\",\n        \"Content-Type: application/http\",\n        \"Content-Transfer-Encoding: binary\",\n        `Content-ID: ${contentId}`,\n        \"\",\n        `${req.config.method} ${this.getRequestURL(req)} HTTP/1.1`,\n        `${this.getHeaders(req)}`,\n        `${this.getBody(req)}`\n      ].join(CRLF);\n    }).join(`${CRLF}--${this.batchUid}`);\n\n    this.batchBody += `${CRLF}--${this.batchUid}--${CRLF}`;\n    if(!changeset){\n      (this.batchConfig.headers as Headers).set(\n        \"Content-Type\",\n        `multipart/mixed;boundary=${this.batchUid}`,\n      );\n    }\n  }\n\n  public async fetch(url: URL) {\n    const req = new ORequest(url, {\n      ...this.batchConfig,\n      body: this.batchBody,\n      method: \"POST\",\n    });\n    const res: Response = await req.fetch;\n    if (res.status === 200) {\n      const data = await res.text();\n      return this.parseResponse(data, res.headers.get(\"Content-Type\"));\n    } else {\n      throw res;\n    }\n  }\n\n  public parseResponse(responseData: string, contentTypeHeader: string): any {\n    const headers = contentTypeHeader.split(\"boundary=\");\n    const boundary = headers[headers.length - 1];\n    const splitData = responseData.split(`--${boundary}`);\n    splitData.shift();\n    splitData.pop();\n    let wasWithChangesetresponse = false;\n    const parsedData = splitData.map((data) => {\n      const dataSegments = data.trim().split(\"\\r\\n\\r\\n\");\n      if (dataSegments.length === 0) {\n        // we are unable to parse -> return all\n        return data;\n      } else if (dataSegments.length > 3) {\n        const header = dataSegments.find(\n            (x) => x.startsWith(\"Content-Type: \") && x.includes(\"boundary=changesetresponse_\"));\n        if (!header) {\n          return data;\n        }\n        dataSegments.shift();\n        wasWithChangesetresponse = true;\n        return this.parseResponse(dataSegments.join(\"\\r\\n\\r\\n\"), header);\n      } else {\n        var contentIdHeader = dataSegments[0].split(\"\\r\\n\").find(function (x) { return x.startsWith(\"Content-ID: \"); });\n        if (contentIdHeader) {\n          try {\n            var contentId = parseInt(contentIdHeader.substring(12), 10);\n          } catch (ex) {\n          }\n        }\n        var status = +dataSegments[1].split(\" \")[1];\n        if (dataSegments.length === 3) {\n          // if length == 3 we have a body, try to parse if JSON and return that!\n          var body;\n          try {\n            const parsed = JSON.parse(dataSegments[2]);\n            const hasFragment = parsed[this.batchConfig.fragment];\n            body = hasFragment || parsed;\n          } catch (ex) {\n            body = dataSegments[2];\n          }\n        }\n        return { contentId, status, body };\n      }\n    });\n    if (wasWithChangesetresponse) {\n        return parsedData[0];\n    }\n    return parsedData;\n  }\n\n  /**\n   * If we determine a changset (POST, PUT, PATCH) we initalize a new\n   * OBatch instance for it.\n   */\n  private checkForChangset(resources: ORequest[], query: OdataQuery) {\n    const changeRes = this.getChangeResources(resources);\n\n    if (this.changeset) {\n      this.batchBody += [\n        \"\",\n        `Content-Type: multipart/mixed;boundary=${this.batchUid}`,\n        \"\",\n        `--${this.batchUid}`\n      ].join(CRLF);\n    } else if (changeRes.length > 0) {\n      this.batchBody = `--${this.batchUid}`;\n      this.batchBody += new OBatch(\n        changeRes,\n        this.batchConfig,\n        query,\n        true,\n      ).batchBody;\n      resources = this.getGETResources(resources);\n    } else {\n      this.batchBody = `--${this.batchUid}`;\n    }\n    return resources;\n  }\n\n  private getGETResources(resources: ORequest[]): ORequest[] {\n    return resources.filter((req) => req.config.method === \"GET\");\n  }\n\n  private getChangeResources(resources: ORequest[]): ORequest[] {\n    return resources.filter((req) => req.config.method !== \"GET\");\n  }\n\n  private getBody(req: ORequest) {\n    if (req.config.body) {\n      return `${req.config.body}${CRLF}${CRLF}`;\n    }\n    return \"\";\n  }\n\n  private getUid() {\n    let d = new Date().getTime();\n    const uuid = \"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx\".replace(/[xy]/g, (c) => {\n      const r = (d + Math.random() * 16) % 16 | 0;\n      d = Math.floor(d / 16);\n      return (c === \"x\" ? r : (r & 0x7) | 0x8).toString(16);\n    });\n    return `${\n      this.changeset\n        ? this.batchConfig.batch.changsetBoundaryPrefix\n        : this.batchConfig.batch.boundaryPrefix\n    }${uuid}`;\n  }\n\n  private getHeaders(req: ORequest): string {\n  // Request headers can be Headers | string[][] | Record<string, string>.\n  // A new Headers instance around them allows treatment of all three types\n  // to be the same. This also applies security last two could bypass.\n  const headers = new Headers(req.config.headers || undefined) as any;\n  // Convert each header to single string.\n  // Headers is iterable. Array.from is needed instead of Object.keys.\n  const mapped = Array.from(headers).map(([k, v]) => `${k}: ${v}`);\n  if (mapped.length) {\n    // Need to ensure a blank line between HEADERS and BODY. When there are\n    // headers, it must be added here. Otherwise blank is added in ctor.\n    mapped.push(\"\");\n  }\n  return mapped.join(CRLF);\n  }\n\n  private getRequestURL(req: ORequest): string {\n  let href = req.url.href;\n  if (this.batchConfig.batch.useRelativeURLs) {\n    // Strip away matching root from request.\n    href = href.replace((this.batchConfig.rootUrl as URL).href, \"\");\n  }\n  return href;\n  }\n}\n","import { OBatch } from \"./OBatch\";\nimport { OdataConfig } from \"./OdataConfig\";\nimport { OdataQuery } from \"./OdataQuery\";\nimport { ORequest } from \"./ORequest\";\n\ntype BodyType = Blob | BufferSource | FormData | URLSearchParams | string | object;\n\nexport class OHandler {\n  private requests: ORequest[] = [];\n\n  constructor(public config: OdataConfig) {}\n\n  /**\n   * Does a fetch request to the given endpoint and request\n   * all resources in sequent. Tries to parse the result logical\n   * so that no further processing is used. If the result is only one\n   * entity a object is returned, otherwise a array of objects.\n   *\n   * @example\n   * ```typescript\n   *  const russell = await o('https://services.odata.org/TripPinRESTierService/')\n   *  .get('People('russellwhyte')\n   *  .query();\n   *\n   *  console.log(russell); // shows: { FirstName: \"Russell\", LastName: \"Whyte\" [...] }\n   * ```\n   *\n   * If the request fails with an error code higher then 400 it throws the\n   * Response:\n   *\n   * @example\n   * ```typescript\n   *  try {\n   *    const unknown = await o('https://services.odata.org/TripPinRESTierService/')\n   *      .get('People('unknown')\n   *      .query();\n   *  } catch(res) { // Response\n   *    console.log(res.status); // 404\n   *  }\n   * ```\n   *\n   * @param query The URLSearchParams that are added to the question mark on the url.\n   *              That are usually the odata queries like $filter, $top, etc...\n   * @returns Either an array or a object with the given entities. If multiple\n   *          resources are fetched, this method returns a array of array/object. If there\n   *          is no content (e.g. for delete) this method returns the Response\n   */\n  public async query(query?: OdataQuery) {\n    try {\n      this.config.onStart(this);\n      const response: Response[] = await this.getFetch(query);\n      const json = await Promise.all(\n        response.map(\n          async (res) => {\n            if (res.status >= 400) {\n              this.config.onError(this, res);\n              throw res;\n            } else if (res.ok && res.json) {\n              try {\n                this.config.onFinish(this, res);\n                const data = await res.json();\n                return data[this.config.fragment] || data;\n              } catch (ex) {\n                return res;\n              }\n            } else {\n              return await res.text();\n            }\n          },\n        ),\n      );\n      return json.length > 1 ? json : json[0];\n    } catch (ex) {\n      throw ex;\n    } finally {\n      this.requests = [];\n    }\n  }\n\n  /**\n   * Request all requests in sequent. Does simply return a Response or Response[]\n   * without any data parsing applied.\n   *\n   * @param query The URLSearchParams that are added to the question mark on the url.\n   *              That are usually the odata queries like $filter, $top, etc...\n   */\n  public async fetch(query?: OdataQuery) {\n    try {\n      this.config.onStart(this);\n      const fetch = await this.getFetch(query);\n      return fetch.length === 1 ? fetch[0] : fetch;\n    } catch (ex) {\n      this.config.onError(this, ex);\n      throw ex;\n    } finally {\n      this.config.onFinish(this);\n      this.requests = [];\n    }\n  }\n\n  /**\n   * Does a batch http-batch request. All request in that sequent are send via one\n   * physically request and afterwards parsed to separate data chunks.\n   *\n   * @param query The URLSearchParams that are added to the question mark on the url.\n   *              That are usually the odata queries like $filter, $top, etc...\n   */\n  public async batch(query?: OdataQuery) {\n    try {\n      const batch = new OBatch(this.requests, this.config, query);\n      const url = this.getUrl(this.config.batch.endpoint);\n      const data = await batch.fetch(url);\n      return data;\n    } catch (ex) {\n      throw ex;\n    } finally {\n      this.requests = [];\n    }\n  }\n\n  /**\n   * Gets the data from the endpoint + resource url.\n   *\n   * @param resource The resource to request e.g. People/$value.\n   */\n  public get(resource: string = \"\") {\n    const url = this.getUrl(resource);\n    const request = new ORequest(url, { ...this.config, method: \"GET\" });\n    this.requests.push(request);\n    return this;\n  }\n\n  /**\n   * Post data to an endpoint + resource.\n   *\n   * @param resource The resource to post to.\n   * @param body The data to post.\n   */\n  public post(resource: string = \"\", body: BodyType) {\n    const url = this.getUrl(resource);\n    const request = new ORequest(url, { ...this.config, method: \"POST\", body: this.getBody(body) });\n    this.requests.push(request);\n    return this;\n  }\n\n  /**\n   * Put data to an endpoint + resource.\n   *\n   * @param resource The resource to put to.\n   * @param body The data to put.\n   */\n  public put(resource: string = \"\", body: BodyType) {\n    const url = this.getUrl(resource);\n    const request = new ORequest(url, { ...this.config, method: \"PUT\", body: this.getBody(body) });\n    this.requests.push(request);\n    return this;\n  }\n\n  /**\n   * Patch data to an endpoint + resource.\n   *\n   * @param resource The resource to patch to.\n   * @param body The data to patch.\n   */\n  public patch(resource: string = \"\", body: BodyType) {\n    const url = this.getUrl(resource);\n    const request = new ORequest(url, {\n      ...this.config,\n      body: this.getBody(body),\n      method: \"PATCH\",\n    });\n    this.requests.push(request);\n    return this;\n  }\n\n  /**\n   * Deletes a resource from the endpoint.\n   *\n   * @param resource The resource to delete e.g. People/1\n   */\n  public delete(resource = \"\") {\n    const url = this.getUrl(resource);\n    const request = new ORequest(url, { ...this.config, method: \"DELETE\" });\n    this.requests.push(request);\n    return this;\n  }\n\n  /**\n   * Use that method to add any kind of request (e.g. a head request) to\n   * the execution list.\n   *\n   * @example\n   * ```typescript\n   *   const req = new ORequest('http://full.url/healt', { method: 'HEAD'});\n   *   const res = await o('http://another.url').request(req).fetch();\n   *   console.log(res.status); // e.g. 200 from http://full.url/healt\n   * ```\n   * @param req The request to add.\n   */\n  public request(req: ORequest) {\n    this.requests.push(req);\n  }\n\n  /**\n   * Determines how many request are outstanding.\n   */\n  public get pending() {\n    return this.requests.length;\n  }\n\n  /**\n   * Returns a URL based on the rootURL + the given resource\n   * @param resource The resource to join.\n   */\n  public getUrl(resource: string) {\n    return new URL(resource, this.config.rootUrl);\n  }\n\n  private async getFetch(query: OdataQuery) {\n    if (this.pending > 1) {\n      const result: Response[] = [];\n      for (const req of this.requests) {\n        req.applyQuery({ ...this.config.query, ...query });\n        const request = await req.fetch;\n        result.push(request);\n      }\n      return result;\n    } else {\n      this.requests[0].applyQuery({ ...this.config.query, ...query });\n      return [await this.requests[0].fetch];\n    }\n  }\n\n  private getBody(body: BodyType): any {\n    if (typeof body === \"object\") {\n      return JSON.stringify(body);\n    }\n    return body;\n  }\n}\n"],"names":["o","rootUrl","config","env","window","global","disablePolyfill","Error","require","shim","defaultConfigValues","batch","boundaryPrefix","changsetBoundaryPrefix","endpoint","headers","Headers","Content-Type","useChangset","useRelativeURLs","credentials","fragment","mode","redirect","referrer","onStart","onError","onFinish","mergedConfig","configUrl","location","href","URL","endsWith","ex","OHandler","url","this","Object","ORequest","req","Request","fetch","query","key","hasOwnProperty","searchParams","get","set","append","CRLF","resources","changeset","batchConfig","batchUid","getUid","checkForChangset","batchBody","forEach","method","applyQuery","contentId","map","_this","getRequestURL","getHeaders","getBody","join","OBatch","body","res","_a","status","text","data","parseResponse","responseData","contentTypeHeader","split","boundary","length","splitData","shift","pop","wasWithChangesetresponse","parsedData","dataSegments","trim","header","find","x","startsWith","includes","contentIdHeader","parseInt","substring","parsed","JSON","parse","changeRes","getChangeResources","getGETResources","filter","d","Date","getTime","uuid","replace","c","r","Math","random","floor","toString","undefined","mapped","Array","from","push","getFetch","response","Promise","all","ok","json","requests","fetch_1","ex_3","getUrl","resource","request","pending","result","_i","_b","stringify"],"mappings":"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"}